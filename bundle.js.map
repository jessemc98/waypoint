{"version":3,"sources":["webpack:///webpack/bootstrap 52da838458533ee1de40","webpack:///./js/colors.js","webpack:///./js/node.js","webpack:///./js/index.js","webpack:///./js/gameboard/draw.js","webpack:///./js/gameboard/index.js","webpack:///./js/gameboard/playerinput.js","webpack:///./js/gameboard/setupInitialMap.js","webpack:///./js/grid.js","webpack:///./js/player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;ACNA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,mBAAmB;AACxB;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD;;AAEpD;AACA,wCAAwC;;;;AAIxC;AACA;AACA,IAAI,2BAA2B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;ACjHA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACRA;;AAEA;AACA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;;ACpBA;AACA;;AAEA;AACwB;AACxB;;8DAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,OAAO;AAChB;AACA;;;AAGA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,C;;;;;;;;;;AChByB;;AAEzB;AACA;AACA,QAAQ,OAAO;AACf;;AAEA;AACA,0BAA0B,YAAY;AACtC;AACA,yBAAyB,aAAa;AACtC;AACA,gCAAgC,aAAa;AAC7C;AACA,yBAAyB,aAAa;AACtC;AACA,gCAAgC,aAAa;AAC7C;AACA,oCAAoC,aAAa;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;AC9CA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA,4BAA4B,aAAa;AACzC,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,CAAC,C;;;;;;;;;;ACpB0C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,UAAU,MAAM;AAChB,UAAU,OAAO;AACjB;;AAEA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 52da838458533ee1de40","export default {\n\tgrass: '#8bc34a',\n\tpath: '#4caf50',\n\tapple: '#f44336',\n\tplayer: '#000000',\n\tjunction: '#673ab7'\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/colors.js\n// module id = 0\n// module chunks = 0","class Node {\n\tconstructor(x, y, type) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.type = type\n\t}\n\n\t// returns array with position of junctions/where junctions should be placed around node\n\tcheckForNodes(getNodeAtPos) {\n\t\treturn [[-1,0], [1,0], [0,1], [0,-1]].reduce((nodes, xY) => {\n\t\t\tconst node = this.checkForJunctionInDirection(\n\t\t\t\t{x: this.x, y: this.y},\n\t\t\t\t{x: xY[0], y: xY[1]}, \n\t\t\t\tgetNodeAtPos)\n\n\t\t\tnode && nodes.push(node)\n\t\t\treturn nodes\n\t\t}, [])\n\t}\n\tcheckForJunctionInDirection(pos, dir, getNodeAtPos, notInitial) {\n\t\tconst nextPos = {\n\t\t\tx: pos.x + dir.x,\n\t\t\ty: pos.y + dir.y\n\t\t}\n\t\tconst next = getNodeAtPos(nextPos.x, nextPos.y)\n\n\t\t// if on initial node and next is not walkable block, no junction\n\t\tif (!notInitial && !this.isWalkable(next)) return false\n\n\t\t// if not on initial node and next is grass, should be a junction\n\t\tif (notInitial && !this.isWalkable(next)) return { x: this.x, y: this.y }\n\n\t\t// if next is junction return that junction\n\t\tif (next.type === 'junction') return { x: next.x, y: next.y }\n\n\t\t\n\n\t\t// if none of the above check next node recursively\n\t\treturn this.checkForJunctionInDirection(\n\t\t\t{x: nextPos.x, y: nextPos.y}, \n\t\t\tdir,\n\t\t\tgetNodeAtPos, \n\t\t\ttrue)\n\t}\n\tisWalkable(node) {\n\t\tif (!node) return false\n\t\tif (node.type === 'grass') return false\n\t\treturn true\n\t}\n}\n\nclass JunctionNode extends Node {\n\n\tlink(dir, node, shouldOpposite) {\n\t\tif (!node) {\n\t\t\tthis[dir][OPPOSITE[dir]] = null\n\t\t\treturn this[dir] = null\n\t\t}\n\t\tconst direction = shouldOpposite ? OPPOSITE[dir] : dir\n\t\tconst opposite = shouldOpposite ? dir : OPPOSITE[dir]\n\t\tthis[direction] = node\n\t\tthis[direction][opposite] = this\n\t}\n\n\tlinkLeft(node) {\n\t\tthis.link('Left', node)\n\t}\n\n\tlinkRight(node) {\n\t\tthis.link('Right', node)\n\t}\n\n\tlinkDown(node) {\n\t\tthis.link('Down', node)\n\t}\n\n\tlinkUp(node) {\n\t\tthis.link('Up', node)\n\t}\n\n\tclearLinks() {\n\t\tthis.Left && this.Left.linkRight(this.Right)\n\t\tthis.Right && this.Right.linkLeft(this.Left)\n\t\tthis.Up && this.Up.linkDown(this.Down)\n\t\tthis.Down && this.Down.linkUp(this.Up)\n\n\t\tthis.Left = this.Right = this.Up = this.Down = null\n\t}\n}\n\nexport const OPPOSITE = {\n\tLeft: 'Right',\n\tRight: 'Left',\n\tUp: 'Down',\n\tDown: 'Up'\n}\n\nexport const TYPES = {\n\tjunction: 'junction',\n\tplayer: 'player'\n}\n\n// creates a node\nexport function createNode(x, y, type) {\n\treturn new Node(x, y, type)\n}\n\nexport function createJunction(x, y) {\n\treturn new JunctionNode(x, y, TYPES.junction)\n}\n\nexport function createPlayer(x, y) {\n\treturn new JunctionNode(x, y, TYPES.player)\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/node.js\n// module id = 1\n// module chunks = 0","import GameBoard from './gameboard'\n\nconst canvas = document.getElementById('game')\nconst game = GameBoard(canvas)\ngame.init()\n\nwindow.game = game\n// TODO create enemy\n// TODO add enemy pathfinding using dvorska and implemented PathNode types\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/index.js\n// module id = 2\n// module chunks = 0","import colors from '../colors'\n\nconst drawGridOnGameBoard = gameBoard => {\n\tconst { ctx, grid, width } = gameBoard\n\tconst blockSize = width / grid.size\n\n\tgameBoard.grid.forEach((x, y, block) => {\n\t\tctx.fillStyle = colors[block.type]\n\t\tctx.fillRect(blockSize * x, blockSize * y, blockSize, blockSize)\n\t})\n}\n\nconst fillGameBoard = (gameBoard, color) => {\n\tgameBoard.ctx.fillStyle = color\n\tgameBoard.ctx.fillRect(0, 0, gameBoard.width, gameBoard.height)\n}\n\nexport default function draw() {\n\tdrawGridOnGameBoard(this)\n\tthis.player.draw()\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/draw.js\n// module id = 3\n// module chunks = 0","import createGrid from '../grid'\nimport createPlayer from '../player'\n\nimport drawGameBoard from './draw'\nimport { setupMovement } from './playerinput'\nimport setupInitialMap from './setupInitialMap'\n\nexport default (canvas) => ({\n\tcanvas,\n\tctx: canvas.getContext('2d'),\n\twidth: canvas.width,\n\theight: canvas.height,\n\tgrid: createGrid(32),\n\tjunctions: [],\n\tdraw: drawGameBoard,\n\tplayer: null,\n\tlastUpdate: performance.now(),\n\tinit() {\n\t\tsetupInitialMap.call(this)\n\t\tthis.player = createPlayer(this)\n\t\t\n\t\t// setup movement listeners\n\t\tsetupMovement(this)\n\n\t\tthis.update.call(this)\n\t},\n\tupdate(dt) {\n\t\t// update every 200 ms\n\t\tif (dt - this.lastUpdate < 200) return requestAnimationFrame(this.update.bind(this))\n\t\tthis.lastUpdate = dt\n\n\t\tthis.player.update()\n\n\t\t// set player block to path block if it is currently grass\n\t\tconst { x, y } = this.player.pos\n\t\tconst node = this.grid.getGridNode(x, y)\n\t\tnode.type === 'grass' && (node.type = 'path')\n\n\n\t\tthis.draw()\n\n\t\trequestAnimationFrame(this.update.bind(this))\n\t}\n})\n\n\n// const spawnAppleAtBlock = (gameBoard, index) => {\n// \tconst i = index || Math.round(Math.random() * Math.pow(gameBoard.grid.size, 2)) - 1\n// \tgameBoard.grid.nodes[i] = 2\n// \tgameBoard.apples += 1\n// }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/index.js\n// module id = 4\n// module chunks = 0","export function setupMovement(gameBoard) {\n\tdocument.addEventListener('keydown', e => {\n\t\tswitch(e.key) {\n\t\t\tcase('w'):\n\t\t\t\treturn gameBoard.player.move('Up')\n\t\t\tcase('d'):\n\t\t\t\treturn gameBoard.player.move('Right')\n\t\t\tcase('s'):\n\t\t\t\treturn gameBoard.player.move('Down')\n\t\t\tcase('a'):\n\t\t\t\treturn gameBoard.player.move('Left')\n\t\t}\n\t})\n\tdocument.addEventListener('keyup', () => gameBoard.player.move())\n\n\trequestAnimationFrame(gameBoard.update.bind(gameBoard))\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/playerinput.js\n// module id = 5\n// module chunks = 0","import { createJunction } from '../node'\n\n// setup the initial paths and waypoints\nexport default function setupInitialPaths() {\n\tconst { size } = this.grid\n\tconst setGridNode = this.grid.setGridNode.bind(this.grid)\n\n\t// draw paths around edges and line in the center\n\tfor(let block = size - 1; block >= 0; block -= 1) {\n\t\t// left\n\t\tsetGridNode(0, block, {type: 'path'})\n\t\t// right\n\t\tsetGridNode(size - 1, block, {type: 'path'})\n\t\t// top\n\t\tsetGridNode(block, 0, {type: 'path'})\n\t\t// bottom\n\t\tsetGridNode(block, size - 1, {type: 'path'})\n\t\t// center\n\t\tsetGridNode(size / 2 - 1, block, {type: 'path'})\n\t}\n\n\t// creates a 'junction' node with pos of ('x', 'y')\n\t// sets gridNode at pos ('x', 'y') to created 'junction'\n\t// pushes 'junction' to this.junctions\n\tconst createJunctionNode = (x, y) => {\n\t\tconst node = createJunction(x, y, 'junction')\n\t\tsetGridNode(x, y, node)\n\t\tthis.junctions.push(node)\n\t\treturn node\n\t}\n\t// set junction nodes for each junction\n\tconst topLeft = createJunctionNode(0, 0)\n\tconst topMid = createJunctionNode(size/2 - 1, 0)\n\tconst topRight = createJunctionNode(size - 1, 0)\n\tconst bottomLeft = createJunctionNode(0, size - 1)\n\tconst bottomMid = createJunctionNode(size/2 - 1, size - 1)\n\tconst bottomRight = createJunctionNode(size - 1, size - 1)\n\n\t// create links between junctions\n\ttopLeft.linkRight(topMid)\n\ttopLeft.linkDown(bottomLeft)\n\ttopMid.linkRight(topRight)\n\ttopMid.linkDown(bottomMid)\n\ttopRight.linkDown(bottomRight)\n\tbottomLeft.linkRight(bottomMid)\n\tbottomMid.linkRight(bottomRight)\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/setupInitialMap.js\n// module id = 6\n// module chunks = 0","export default (size) => ({\n\tsize,\n\tnodes: Array(size * size).fill(0).map(_ => ({type: 'grass'})),\n\tgetGridNode(x, y) {\n\t\tif (x < 0 || x >= size || y < 0 || y >= size) return null\n\t\treturn this.nodes[x + y * this.size]\n\t},\n\tsetGridNode(x, y, value) {\n\t\tif (x < 0 || x >= size || y < 0 || y >= size) return null\n\t\tconst index = x + y * this.size\n\n\t\tthis.nodes[index] = value\n\t},\n\tforEach(fn) {\n\t\tfor(let column = size - 1; column >= 0; column -= 1){\n\t\t\tfor(let row = size - 1; row >= 0; row -= 1){\n\t\t\t\tfn(row, column, this.nodes[row + column * this.size])\n\t\t\t}\n\t\t}\n\t}\n})\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/grid.js\n// module id = 7\n// module chunks = 0","import { createPlayer as createPlayerNode } from './node'\nimport colors from './colors'\n\n// create player\nexport default (gameBoard) => {\n\tconst getGridNode = gameBoard.grid.getGridNode.bind(gameBoard.grid)\n\tconst setGridNode = gameBoard.grid.setGridNode.bind(gameBoard.grid)\n\tconst initialPos = {\n\t\tx: 0,\n\t\ty: gameBoard.grid.size / 2 - 1\n\t}\n\tconst node = createPlayerNode(0, gameBoard.grid.size / 2 - 1)\n\tnode.linkUp(getGridNode(0, 0))\n\tnode.linkDown(getGridNode(0,31))\n\t\n\n\tconst updateNode = function () {\n\t\tconst current = this.getCurrentNode()\n\t\tconst next = this.getNextNode()\n\n\t\t// if moving from junction to junction, do nothing\n\t\t// if(current.type === 'junction' && next.type === 'junction') return\n\n\t\t// if moving from junction to path\n\t\tif(current.type === 'junction' && next.type === 'path') {\n\t\t\tconst opposite = true\n\t\t\tconsole.log(this)\n\t\t\tthis.node.clearLinks()\n\n\t\t\tcurrent[this.dir].link(this.dir, this.node, opposite)\n\t\t\tcurrent.link(this.dir, node)\n\t\t}\n\t\t// if moving from path to grass\n\t\tif(current.type === 'path' &&\n\t\t\tnext.type === 'grass') {\n\t\t//TODO if moving from path to grass but in same axis as previous step do nothing\n\t\t\tlet copy = Object.assign(createPlayerNode(), this.node)\n\t\t\tthis.node.type = 'junction'\n\n\t\t\tsetGridNode(this.pos.x, this.pos.y, this.node)\n\t\t\tthis.node = copy\n\t\t}\n\t\t// move player node\n\t\tthis.node.x += this.vel.x\n\t\tthis.node.y += this.vel.y\n\t}\n\treturn {\n\t\tnode,\n\t\tpos: initialPos,\n\t\tvel: { x: 0, y: 0 },\n\t\tgetCurrentNode() {\n\t\t\treturn getGridNode(this.pos.x, this.pos.y)\n\t\t},\n\t\tgetNextNode() {\n\t\t\treturn getGridNode(this.pos.x + this.vel.x, this.pos.y + this.vel.y)\n\t\t},\n\t\tmove(dir) {\n\t\t\tthis.dir = dir\n\t\t\t// if no direction stop moving\n\t\t\tif (!dir) {\n\t\t\t\treturn this.vel.x = this.vel.y = 0 }\n\n\t\t\tthis['move' + dir]()\n\t\t},\n\t\tmoveUp() {\n\t\t\treturn this.pos.y !== 0 && (this.vel.y = -1)\n\t\t},\n\t\tmoveRight() {\n\t\t\treturn this.pos.x !== gameBoard.grid.size - 1 && (this.vel.x = 1)\n\t\t},\n\t\tmoveDown() {\n\t\t\treturn this.pos.y !== gameBoard.grid.size - 1 && (this.vel.y = 1)\n\t\t},\n\t\tmoveLeft() {\n\t\t\treturn this.pos.x !== 0 && (this.vel.x = -1)\n\t\t},\n\t\tupdate() {\n\t\t\tupdateNode.call(this)\n\t\t\tthis.pos.x += this.vel.x\n\t\t\tthis.pos.y += this.vel.y\n\t\t},\n\t\tdraw() {\n\t\t\tconst { ctx } = gameBoard\n\t\t\tconst { x, y } = this.pos\n\t\t\tconst size = gameBoard.width / gameBoard.grid.size\n\n\t\t\tctx.fillStyle = colors[this.node.type]\n\t\t\tctx.fillRect(x * size + 5, y * size + 5, size - 10, size - 10)\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}
{"version":3,"sources":["webpack:///webpack/bootstrap c0e891858a0eddf780a1","webpack:///./js/constants.js","webpack:///./js/colors.js","webpack:///./js/index.js","webpack:///./js/enemy.js","webpack:///./js/gameboard/draw.js","webpack:///./js/gameboard/index.js","webpack:///./js/gameboard/junctionWaypoints.js","webpack:///./js/gameboard/playerinput.js","webpack:///./js/grid.js","webpack:///./js/node.js","webpack:///./js/pathfinding.js","webpack:///./js/player.js","webpack:///./js/gameboard/interface.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;AChEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA,4BAAmC;AAAA;AAAA;AACnC;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACPA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACRA;AACmB;;AAEU;AAC7B;AACA;AACA,OAAO,QAAQ;AACf,sBAAsB;AACtB;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,SAAS,MAAM;AACf,SAAS,OAAO;AAChB;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACjDD;;AAEA;AACA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACrBA;AACA;;AAE2C;AAC3C;AACwB;AACqB;AAC7C;;8DAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACjGe;AACf;AACqB;AACrB;;AAEA;AACA,SAAS,wBAAwB;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,WAAW;AAChB,KAAK,kBAAkB;AACvB,KAAK,kBAAkB;AACvB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA,eAAe,cAAc;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,aAAa;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,UAAU;AACtE;AACA;AACA;AACA,6CAA6C,iCAAiC;;AAE9E;;AAEA,qDAAqD,sBAAsB;;AAE3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjCqB;AACrB,6EAA8B,mEAAuB;AACrD;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA,4BAA4B,aAAa;AACzC,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACtB+B;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;AC/DA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA,+BAAsC,WAAW;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrGA;AAC6B;AAC7B;AACA;AACA,sBAAsB;AACtB,OAAO,aAAa;AACpB;AACA,SAAS,MAAM;AACf,SAAS,OAAO;AAChB;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CD;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c0e891858a0eddf780a1","export const GRID_SIZE = 16\nexport const GAME_STEP = (1000/60) * 12\n\nexport const TERMINATE_MOVEMENT = { x:0, y:0 }\nexport const OPPOSITES = {\n\tLeft: 'Right',\n\tRight: 'Left',\n\tUp: 'Down',\n\tDown: 'Up'\n}\n\nexport const NODE_TYPES = {\n  apple: 'APPLE',\n  // junction nodes\n\tjunction: 'JUNCTION',\n\tplayer: 'PLAYER',\n\tenemy: 'ENEMY',\n  // used for waypoint making and styling\n  path: 'PATH',\n  grass: 'GRASS'\n}\n\n// nodes which enemies cant step on\nexport const SOLID_NODES = ['GRASS', 'APPLE']\n\nexport const INITIAL_PLAYER_POS = {\n  x: 0,\n  y: GRID_SIZE / 2 -1\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/constants.js\n// module id = 0\n// module chunks = 0","export default {\n\tGRASS: '#8bc34a',\n\tPATH: '#459e49',\n\tENEMY: '#000000',\n\tAPPLE: '#a41b11',\n\tPLAYER: '#ffffff',\n\tJUNCTION: '#459e49'//'#673ab7'\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/colors.js\n// module id = 1\n// module chunks = 0","import GameBoard from './gameboard'\n\nconst canvas = document.getElementById('game')\nconst game = GameBoard(canvas)\ngame.init()\n\nwindow.game = game\n// TODO create enemy\n// TODO add enemy pathfinding using dvorska and implemented PathNode types\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/index.js\n// module id = 2\n// module chunks = 0","import colors from './colors'\nimport { findPath } from './pathfinding'\n\nimport { TERMINATE_MOVEMENT } from './constants'\n// create enemy on gameBoard\nexport default (x, y, gameBoard) => ({\n\tpos: { x , y },\n\tvel: Object.assign({}, TERMINATE_MOVEMENT),\n\twayPoints: [],\n\tgetWayPointsToPlayer() {\n\t\treturn this.wayPoints = findPath(this.node, gameBoard.player.node)\n\t},\n\tmoveToNextWaypoint() {\n\t\t// if que is empty, return, no waypoint to go to\n\t\tif (this.wayPoints.length < 1) return this.vel = TERMINATE_MOVEMENT\n\n\t\tconst next = this.wayPoints[0].junction\n\n\t\t// if at next waypoint, remove from wayPoint que and make recursive call\n\t\tif (this.pos.x === next.x && this.pos.y === next.y) {\n\t\t\tthis.wayPoints.shift()\n\t\t\tthis.vel = TERMINATE_MOVEMENT\n\n\t\t\treturn this.moveToNextWaypoint()\n\t\t}\n\n\t\t// default behaviour, set velocity so we eventually reach next waypoint\n\t\tconst distX = this.pos.x - next.x\n\t\tconst distY = this.pos.y - next.y\n\n\t\tthis.vel = {\n\t\t\tx: distX === 0 ? 0 : distX < 0 ? 1 : -1,\n\t\t\ty: distY === 0 ? 0 : distY < 0 ? 1 : -1\n\t\t}\n\t},\n\tdraw() {\n\t\tconst { ctx } = gameBoard\n\t\tconst { x, y } = this.pos\n\t\tconst size = gameBoard.width / gameBoard.grid.size\n\n\t\tctx.fillStyle = colors.ENEMY\n\t\tctx.fillRect(x * size + 5, y * size + 5, size - 10, size - 10)\n\t},\n\tupdate() {\n\t\tthis.moveToNextWaypoint()\n\n\t\tthis.pos.x += this.vel.x\n\t\tthis.pos.y += this.vel.y\n\t}\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/enemy.js\n// module id = 3\n// module chunks = 0","import colors from '../colors'\n\nconst drawGridOnGameBoard = gameBoard => {\n\tconst { ctx, grid, width } = gameBoard\n\tconst blockSize = width / grid.size\n\n\tgameBoard.grid.forEach((x, y, block) => {\n\t\tctx.fillStyle = colors[block.type]\n\t\tctx.fillRect(blockSize * x, blockSize * y, blockSize, blockSize)\n\t})\n}\n\nconst fillGameBoard = (gameBoard, color) => {\n\tgameBoard.ctx.fillStyle = color\n\tgameBoard.ctx.fillRect(0, 0, gameBoard.width, gameBoard.height)\n}\n\nexport default function draw() {\n\tdrawGridOnGameBoard(this)\n\tthis.player.draw()\n\tthis.enemies.forEach(enemy => enemy.draw())\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/draw.js\n// module id = 4\n// module chunks = 0","import createPlayer from '../player'\nimport createEnemy from '../enemy'\n\nimport { GAME_STEP, GRID_SIZE, NODE_TYPES } from '../constants'\nimport drawGameBoard from './draw'\nimport { setupMovement } from './playerinput'\nimport waypointSystem, { createWaypointGrid } from './junctionWaypoints'\nimport ui from './interface'\n\nexport default (canvas) => ({\n\tcanvas,\n\tctx: canvas.getContext('2d'),\n\twidth: canvas.width,\n\theight: canvas.height,\n\tgrid: createWaypointGrid(GRID_SIZE),\n\tdraw: drawGameBoard,\n\tenemies: [],\n\tapples: 0,\n\tinit() {\n\t\t// setup ui\n\t\tthis.ui = ui(this)\n\n\t\t// setup player\n\t\tthis.player = createPlayer(this)\n\t\t// setup keyboard listeners\n\t\tsetupMovement(this)\n\n\t\t// make some enemies\n\t\tthis.enemies.push(createEnemy(GRID_SIZE - 1, GRID_SIZE - 1, this))\n\t\tthis.enemies.push(createEnemy(GRID_SIZE - 6, 0, this))\n\t\tthis.enemies.push(createEnemy(GRID_SIZE - 1, GRID_SIZE / 2, this))\n\n\t\t// setup grid/waypoint system\n\t\tthis.waypoints = waypointSystem(this)\n\n\t\t// make some apples\n\t\t// topleft\n\t\tspawnAppleAtBlock(this, 3, 3)\n\t\tspawnAppleAtBlock(this, 3, 6)\n\t\tspawnAppleAtBlock(this, 3, 9)\n\t\tspawnAppleAtBlock(this, 6, 3)\n\t\tspawnAppleAtBlock(this, 6, 6)\n\t\tspawnAppleAtBlock(this, 6, 9)\n\t\t// bottomleft\n\t\tspawnAppleAtBlock(this, 3, GRID_SIZE - 4)\n\t\tspawnAppleAtBlock(this, 3, GRID_SIZE - 7)\n\t\tspawnAppleAtBlock(this, 3, GRID_SIZE - 10)\n\t\tspawnAppleAtBlock(this, 6, GRID_SIZE - 4)\n\t\tspawnAppleAtBlock(this, 6, GRID_SIZE - 7)\n\t\tspawnAppleAtBlock(this, 6, GRID_SIZE - 10)\n\t\t// topright\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, 3)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, 6)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, 9)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, 3)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, 6)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, 9)\n\t\t// topleft\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, GRID_SIZE - 4)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, GRID_SIZE - 7)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 4, GRID_SIZE - 10)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, GRID_SIZE - 4)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, GRID_SIZE - 7)\n\t\tspawnAppleAtBlock(this, GRID_SIZE - 7, GRID_SIZE - 10)\n\n\t\t// draw initial state\n\t\tthis.draw()\n\t\tthis.update.call(this)\n\t},\n\t// GAME LOOP\n\tlastUpdate: null,\n\tpause: true,\n\tupdate(dt) {\n\t\tif (this.pause) return requestAnimationFrame(this.update.bind(this))\n\t\tlet timePast = dt - this.lastUpdate\n\t\twhile (timePast > GAME_STEP) {\n\t\t\ttimePast -= GAME_STEP\n\t\t\tthis.lastUpdate += GAME_STEP\n\n\t\t\t// update entity positions\n\t\t\tthis.player.update()\n\t\t\tthis.enemies.forEach(enemy => enemy.update())\n\n\t\t\tthis.waypoints.update()\n\t\t}\n\t\tthis.draw()\n\n\t\trequestAnimationFrame(this.update.bind(this))\n\t}\n})\n\nfunction spawnAppleAtBlock(gameBoard, X, Y) {\n\tconst x = X || Math.round(Math.random() * GRID_SIZE) - 1\n\tconst y = Y || Math.round(Math.random() * GRID_SIZE) - 1\n\tconst node = gameBoard.grid.getGridNode(x, y)\n\tif (node.type === NODE_TYPES.grass) {\n\t\tnode.type = NODE_TYPES.apple\n\n\t\tgameBoard.apples += 1\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/index.js\n// module id = 5\n// module chunks = 0","import {\n  createJunction,\n  createPlayer,\n  createEnemy } from '../node.js'\nimport createGrid from '../grid.js'\nimport { NODE_TYPES } from '../constants'\nconst ABS = Math.abs\n\nexport default function waypointSystem(gameBoard) {\n  const { player, enemies, grid } = gameBoard\n  const walkSound = new Audio('./walk.mp3')\n  const appleSound = new Audio('./apple.mp3')\n  const deathSound = new Audio('./enemy.mp3')\n\n  player.node = createPlayer(player.pos.x, player.pos.y)\n\n  enemies.map(enemy =>\n    enemy.node = createEnemy(enemy.pos.x, enemy.pos.y))\n\n  let prevWayPoints = {\n    Left: player.node.Left,\n    Right: player.node.Right,\n    Up: player.node.Up,\n    Down: player.node.Down\n  }\n  return {\n    update() {\n      const prevConnections = getJunctionNeighbours(player.node)\n      // if player has moved update player junction node\n      if (!(player.pos.x === player.node.x && player.pos.y === player.node.y)) {\n        walkSound.currentTime = 0\n        walkSound.play()\n\n        player.node.clearLinks()\n        updatePos(player.node, player.pos)\n\n        linkJunctionToNeighbours(player.node, grid)\n\n        const nodeAtPlayer = grid.getGridNode(player.node.x, player.node.y)\n        // turn grass to path if player is on grass node\n        if (nodeAtPlayer.type === NODE_TYPES.grass) nodeAtPlayer.type = NODE_TYPES.path\n        // eat apple if player is on apple node\n        if (nodeAtPlayer.type === NODE_TYPES.apple) {\n          appleSound.currentTime = 0\n          appleSound.play()\n          nodeAtPlayer.type = NODE_TYPES.path\n          gameBoard.apples -= 1\n        }\n        // check if player has collected all apples\n        if (gameBoard.apples === 0 ) {\n          gameBoard.apples -= 1\n          gameBoard.ui.win()\n        }\n\n        prevConnections.forEach(connection => linkJunctionToNeighbours(connection, grid, player.node))\n      }\n\n      // update enemy junction nodes\n      enemies.forEach((enemy, i) => {\n        const prevConnections = getJunctionNeighbours(enemy.node)\n        enemy.node.clearLinks()\n\n        updatePos(enemy.node, enemy.pos)\n        linkJunctionToNeighbours(enemy.node, grid)\n\n        prevConnections.forEach(connection => linkJunctionToNeighbours(connection, grid, player.node))\n      })\n      // check if enemies have caught player\n      enemies.forEach(enemy => {\n        if (enemy.pos.x === player.pos.x && enemy.pos.y === player.pos.y) {\n          deathSound.currentTime = 0\n          deathSound.play()\n          return gameBoard.ui.gameOver()\n        }\n      })\n\n      // if player connections have changed recalculate enemy paths\n      if (\n        prevWayPoints.Left !== player.node.Left ||\n        prevWayPoints.Right !== player.node.Right ||\n        prevWayPoints.Up !== player.node.Up ||\n        prevWayPoints.Down !== player.node.Down ) {\n        enemies.forEach(enemy => enemy.getWayPointsToPlayer())\n      }\n      prevWayPoints = {\n        Left: player.node.Left,\n        Right: player.node.Right,\n        Up: player.node.Up,\n        Down: player.node.Down\n      }\n    }\n  }\n}\n\n// expects size to be an INT\n// expects initialWaypoints to be an array with vector objects\n// returns Grid with waypoints added to the grid and paths created between them\nexport function createWaypointGrid(size) {\n  const waypointGrid = createGrid(size)\n  const initialWaypoints = [\n    {x: 0, y: 0},\n    {x: size - 1, y: 0},\n    {x: 0, y: size - 1},\n    {x: size - 1, y: size - 1}\n  ]\n  // draw paths around edges\n  drawPathBetweenJunctions([initialWaypoints[0], initialWaypoints[1]], waypointGrid)\n  drawPathBetweenJunctions([initialWaypoints[0], initialWaypoints[2]], waypointGrid)\n  drawPathBetweenJunctions([initialWaypoints[2], initialWaypoints[3]], waypointGrid)\n  drawPathBetweenJunctions([initialWaypoints[1], initialWaypoints[3]], waypointGrid)\n  // set initial waypoints on grid and link to each other\n  initialWaypoints\n    .map(waypoint => createJunction(waypoint.x, waypoint.y))\n    .map(junction => waypointGrid.setGridNode(junction.x, junction.y, junction))\n    .map(junction => linkJunctionToNeighbours(junction, waypointGrid))\n\n  return waypointGrid\n}\n\n// expects:\n//   an array of exactly 2, currently linked, Junction nodes.\n//   a Grid object\n// sets every node between junctions to be of type NODE_TYPES.path if it is not of type 'junction'\nfunction drawPathBetweenJunctions(junctions, grid) {\n  const path = getPathBetweenJunctions(junctions[0], junctions[1])\n    for (let next = path.next(); next = path.next();) {\n\n      if (!next) return\n      const gridNode = grid.getGridNode(next.x, next.y)\n\n      // set node type to path if not a junction\n      if (gridNode.type !== NODE_TYPES.junction) gridNode.type = NODE_TYPES.path\n    }\n}\n\n// expects: a and b to be two linked nodes\n// returns array of vector objects starting at pos a ending at pos b\nfunction getPathBetweenJunctions(a, b) {\n  const distAndDir = getDisanceAndDirection(a, b)\n\n  let currentPos = Object.assign({}, a)\n  let distance = Math.max(distAndDir.distance.x, distAndDir.distance.y)\n  // for each node between first junction and second junction\n  const path = []\n  for(distance; distance > 0; distance -= 1) {\n    path.push(Object.assign({},currentPos))\n    currentPos.x += distAndDir.direction.x\n    currentPos.y += distAndDir.direction.y\n  }\n  return {\n    path,\n    next() {\n      if (path[0]) return this.path.splice(0, 1)[0]\n\n      return null\n    }\n  }\n}\nwindow.distance = getDisanceAndDirection\nfunction getDisanceAndDirection(current, target) {\n  const distance = {\n    x: target.x - current.x,\n    y: target.y - current.y\n  }\n  // turn into direction vector, normalize or w/e you call it in math mumbo jumbo\n  const direction = {\n    x: distance.x == 0 ? 0 : (1 / distance.x) * ABS(distance.x + distance.y),\n    y: distance.y == 0 ? 0 : (1 / distance.y) * ABS(distance.x + distance.y)\n  }\n  return { distance, direction }\n}\n\n// returns junctions already linked to given junction\nfunction getJunctionNeighbours(junction) {\n  return (['Right', 'Left', 'Up', 'Down']\n    .reduce((total, direction) => {\n      const link = junction[direction]\n      link && total.push(link)\n      return total\n    }, []))\n}\n\n// if player is defined will treat player as a possible waypoint\nfunction linkJunctionToNeighbours(junction, grid, player) {\n  // console.log('linking', Object.assign({}, junction), 'to');\n  const neighbours = checkJunctionForNeighbours(junction, grid, player)\n  neighbours\n    .map(neighbour => neighbour === player ?\n      player:\n      grid.getGridNode(neighbour.x, neighbour.y))\n    // set neighbour to junction if not already a junction\n    .map(neighbour => {\n      // console.log('neighbour', Object.assign({}, neighbour));\n      if (!(neighbour.type === NODE_TYPES.junction || neighbour.type === NODE_TYPES.player)) {\n\n        neighbour = createJunction(neighbour.x, neighbour.y)\n        // console.log('created junction', Object.assign({}, neighbour));\n        // console.log('calling link junc to neighbour recursively');\n        linkJunctionToNeighbours(neighbour, grid, player)\n\n        return grid.setGridNode(neighbour.x, neighbour.y, neighbour)\n      }\n      return neighbour\n    })\n    .map(neighbourNode => linkGivenJunctions(junction, neighbourNode))\n    // console.log('end link');\n  return junction\n}\n\n// links two junctions\nfunction linkGivenJunctions(a, b) {\n  const dir = vectorToDirection(\n    getDisanceAndDirection(a, b).direction)\n\n  return a.link(dir, b)\n}\n\nfunction vectorToDirection(xY) {\n  const directions = {\n    '1': {'0': 'Right'},\n    '-1': {'0': 'Left'},\n    '0': {\n      '1': 'Down',\n      '-1': 'Up'\n    }\n  }\n  return directions[xY.x][xY.y]\n}\n\nfunction checkJunctionForNeighbours(junction, grid, player={x:-1,y:-1}) {\n  const directions = [[-1,0], [1,0], [0,1], [0,-1]]\n  return (\n    directions.reduce((neighbours, direction) => {\n      const tracer = createTracer(junction, {x: direction[0], y: direction[1]}, grid)\n\n      let next\n\n      tracer.next((prevNode, currNode, i) => next = {prevNode, currNode, i})\n\n      while (next.currNode) {\n\n        if (next.currNode.x === player.x && next.currNode.y === player.y) {\n          neighbours.push(player)\n          return neighbours\n        }\n        if (next.currNode.type === NODE_TYPES.junction) {\n          neighbours.push(next.currNode)\n          return neighbours\n        }\n        if (next.currNode.type === NODE_TYPES.grass || next.currNode.type === NODE_TYPES.apple) {\n          if (next.i === 0) return neighbours\n          neighbours.push(next.prevNode)\n          return neighbours\n        }\n        tracer.next((prevNode, currNode, i) => next = {prevNode, currNode, i})\n      }\n      if (next.i === 0) return neighbours\n      neighbours.push(next.prevNode)\n      return neighbours\n    }, []))\n}\n\nfunction createTracer(start, direction, grid) {\n  let iteration = 0\n  let currentPos = Object.assign({}, start)\n  let prevNode;\n  return {\n    next(fn) {\n      const current = {\n        x: currentPos.x += direction.x,\n        y: currentPos.y += direction.y\n      }\n\n      const node = grid.getGridNode(current.x, current.y)\n      if (node) Object.assign(node, current)\n\n      fn(prevNode, node, iteration)\n      prevNode = node\n      iteration += 1\n    }\n  }\n}\n\nfunction updatePos(a, b) {\n  a.x = b.x\n  a.y = b.y\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/junctionWaypoints.js\n// module id = 6\n// module chunks = 0","export function setupMovement(gameBoard) {\n\tconst state = []\n\tdocument.addEventListener('keydown', e => {\n\t\tif (e.key === 'w' || e.key === 'a' || e.key === 's' || e.key === 'd') {\n\t\t\tif (state.indexOf(e.key) === -1) {\n\t\t\t\tstate.unshift(e.key)\n\t\t\t}\n\t\t}\n\n\t\tmovePlayer(state[0], gameBoard.player)\n\t})\n\tdocument.addEventListener('keyup', e => {\n\t\tconst i = state.indexOf(e.key)\n\t\tif (i > -1) {\n\t\t\tstate.splice(i, 1)\n\t\t}\n\t\tmovePlayer(state[0], gameBoard.player)\n\t})\n}\n\nfunction movePlayer(dir, player) {\n\tswitch(dir) {\n\t\tcase('w'):\n\t\t\treturn player.move('Up')\n\t\tcase('d'):\n\t\t\treturn player.move('Right')\n\t\tcase('s'):\n\t\t\treturn player.move('Down')\n\t\tcase('a'):\n\t\t\treturn player.move('Left')\n\t\tdefault:\n\t\t\treturn player.move()\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/playerinput.js\n// module id = 7\n// module chunks = 0","import { NODE_TYPES } from './constants'\nexport default (size, filler={type: NODE_TYPES.grass}) => ({\n\tsize,\n\tnodes: Array(size * size).fill(0).map(_ => Object.assign({},filler)),\n\n\tgetGridNode(x, y) {\n\t\tif (x < 0 || x >= size || y < 0 || y >= size) return null\n\t\treturn this.nodes[x + y * this.size]\n\t},\n\tsetGridNode(x, y, value) {\n\t\tif (x < 0 || x >= size || y < 0 || y >= size) return null\n\t\tconst index = x + y * this.size\n\n\t\treturn this.nodes[index] = value\n\t},\n\tforEach(fn) {\n\t\tfor(let column = size - 1; column >= 0; column -= 1){\n\t\t\tfor(let row = size - 1; row >= 0; row -= 1){\n\t\t\t\tfn(row, column, this.nodes[row + column * this.size])\n\t\t\t}\n\t\t}\n\t}\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/grid.js\n// module id = 8\n// module chunks = 0","import { NODE_TYPES, OPPOSITES } from './constants'\n\nclass Node {\n\tconstructor(x, y, type) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.type = type\n\t}\n}\n\nclass JunctionNode extends Node {\n\n\tlink(dir, node, shouldOpposite) {\n\t\tif (!node) {\n\t\t\tthis[dir][OPPOSITES[dir]] = null\n\t\t\treturn this[dir] = null\n\t\t}\n\t\tconst direction = shouldOpposite ? OPPOSITES[dir] : dir\n\t\tconst opposite = shouldOpposite ? dir : OPPOSITES[dir]\n\t\tthis[direction] = node\n\t\tthis[direction][opposite] = this\n\t}\n\n\tlinkLeft(node) {\n\t\tthis.link('Left', node)\n\t}\n\n\tlinkRight(node) {\n\t\tthis.link('Right', node)\n\t}\n\n\tlinkDown(node) {\n\t\tthis.link('Down', node)\n\t}\n\n\tlinkUp(node) {\n\t\tthis.link('Up', node)\n\t}\n\n\tclearLinks() {\n\t\tthis.Left && this.Left.linkRight(this.Right)\n\t\tthis.Right && this.Right.linkLeft(this.Left)\n\t\tthis.Up && this.Up.linkDown(this.Down)\n\t\tthis.Down && this.Down.linkUp(this.Up)\n\n\t\tthis.Left = this.Right = this.Up = this.Down = null\n\t}\n}\n\nexport function createNode(x, y, type) {\n\treturn new Node(x, y, type)\n}\n\nexport function createJunction(x, y) {\n\treturn new JunctionNode(x, y, NODE_TYPES.junction)\n}\n\nexport function createPlayer(x, y) {\n\treturn new JunctionNode(x, y, NODE_TYPES.player)\n}\n\nexport function createEnemy(x, y) {\n\treturn new JunctionNode(x, y, NODE_TYPES.enemy)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/node.js\n// module id = 9\n// module chunks = 0","const ABS = Math.abs\n\nexport function createInitialWayPoint(initial, target) {\n\treturn {\n\t\tjunction: initial,\n\t\th: getEuclideanDistance(initial, target),\n\t\tg: 0\n\t}\n}\n\nexport function getWaypointJunctionNodes(wayPoint, target) {\n\treturn getWaypointJunctions(wayPoint)\n\t\t.map( junction => {\n\t\t\tconst h = getEuclideanDistance(junction, target)\n\t\t\tconst g = getEuclideanDistance(junction, wayPoint.junction) + (wayPoint.parent? wayPoint.parent.g : 0)\n\t\t\treturn {\n\t\t\t\tjunction,\n\t\t\t\th,\n\t\t\t\tg,\n\t\t\t\tf: g + h,\n\t\t\t\tparent: wayPoint\n\t\t\t}\n\t\t})\n}\nwindow.findPath = findPath\nexport function findPath(current, target) {\n\tconst initialWaypoint = createInitialWayPoint(current, target)\n\tconst openList = getWaypointJunctionNodes(initialWaypoint, target)\n\tconst closedList = [initialWaypoint]\n\n\twhile (openList.length > 0) {\n\t\tconst currentIndex = getNextNodeIndex(openList)\n\t\tconst current = openList.splice(currentIndex, 1)[0]\n\n\t\t// if at target pos return path\n\t\tif (current.junction.x === target.x && current.junction.y === target.y)\n\t\t\treturn tracePath(current)\n\n\t\tclosedList.push(current)\n\n\t\tconst neighbours = getWaypointJunctions(current)\n\t\tneighbours.forEach(neighbour => {\n\t\t\t// if in closed list, already checked\n\t\t\tif (closedList.find(findJunction(neighbour))) return\n\n\t\t\tconst newG = getEuclideanDistance(current.junction, neighbour) + (current.parent? current.parent.g : 0)\n\t\t\tconst newH = getEuclideanDistance(neighbour, target)\n\t\t\tconst newWaypoint = {\n\t\t\t\tjunction: neighbour,\n\t\t\t\tparent: current,\n\t\t\t\th: newH,\n\t\t\t\tg: newG,\n\t\t\t\tf: newG + newH\n\t\t\t}\n\t\t\tconst wayPointInOpenList = openList.find(findJunction(neighbour))\n\t\t\t// if not in openList, discovered a new node \n\t\t\tif (!wayPointInOpenList) return openList.push(newWaypoint)\n\n\t\t\t// if greater g value, is further away\n\t\t\tif (wayPointInOpenList.g < newWaypoint.g) return\n\n\t\t\t// new path is better than old, record it\n\t\t\tObject.assign(wayPointInOpenList, newWaypoint)\n\t\t})\n\t}\n}\nexport function findJunction(junction) {\n\treturn x => x.junction === junction\n}\n\nexport function getNextNodeIndex(openList) {\n\tlet low = Infinity\n\tlet index = 0\n\n\topenList.forEach((waypoint, currentIndex) => {\n\t\tif (waypoint.f < low) {\n\t\t\tlow = waypoint.f\n\t\t\tindex = currentIndex\n\t\t}\n\t})\n\treturn index\n}\n\nexport function getEuclideanDistance(current, target) {\n\treturn ABS(current.x - target.x) + ABS(current.y - target.y)\n}\n\nexport function getWaypointJunctions({ junction }) {\n\treturn ['Up', 'Down', 'Left', 'Right']\n\t\t.map(dir => junction[dir])\n\t\t.filter(junc => junc)\n}\n\n// climbs the parent tree of a waypoint and returns: \n//   an array of waypoints with array[0] being the root node of the path\nexport function tracePath(endPoint) {\n\tconst path = [endPoint]\n\twhile (path[0].parent) {\n\t\tpath.unshift(path[0].parent)\n\t}\n\treturn path\n}\n\n\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/pathfinding.js\n// module id = 10\n// module chunks = 0","import colors from './colors'\nimport { INITIAL_PLAYER_POS } from './constants'\n// create player\nexport default (gameBoard) => ({\n\tpos: Object.assign({}, INITIAL_PLAYER_POS),\n\tvel: { x: 0, y: 0 },\n\tdraw() {\n\t\tconst { ctx } = gameBoard\n\t\tconst { x, y } = this.pos\n\t\tconst size = gameBoard.width / gameBoard.grid.size\n\n\t\tctx.fillStyle = colors.PLAYER\n\t\tctx.fillRect(x * size + 5, y * size + 5, size - 10, size - 10)\n\t},\n\tmove(dir) {\n\t\tthis.dir = dir\n\t\tthis.vel.x = this.vel.y = 0\n\t\t// if no direction stop moving\n\t\tif (!dir) {\n\t\t\treturn this.dir = null\n\t\t}\n\n\t\tthis['move' + dir]()\n\t},\n\tmoveUp() {\n\t\treturn this.pos.y !== 0 && (this.vel.y = -1)\n\t},\n\tmoveRight() {\n\t\treturn this.pos.x !== gameBoard.grid.size - 1 && (this.vel.x = 1)\n\t},\n\tmoveDown() {\n\t\treturn this.pos.y !== gameBoard.grid.size - 1 && (this.vel.y = 1)\n\t},\n\tmoveLeft() {\n\t\treturn this.pos.x !== 0 && (this.vel.x = -1)\n\t},\n\tupdate() {\n\t\tthis.move(this.dir)\n\n\t\tthis.pos.x += this.vel.x\n\t\tthis.pos.y += this.vel.y\n\t}\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 11\n// module chunks = 0","export default function setupInterface(gameboard) {\n  const startButton = createButton('START GAME', 'ui-button', e => {\n    play(gameboard)\n    gameboard.lastUpdate = performance.now()\n\n    document.body.removeChild(e.target)\n  })\n  const gameOverButton = createButton('GAME OVER!', 'ui-button flashing disabled')\n  const youWinButton = createButton('YOU WIN!!!', 'ui-button flashing disabled')\n\n  document.body.appendChild(startButton)\n\n  return {\n    gameOver() {\n      pause(gameboard)\n      document.body.appendChild(gameOverButton)\n    },\n    win() {\n      pause(gameboard)\n      document.body.appendChild(youWinButton)\n    }\n  }\n}\n\nfunction play(gameboard) {\n  return gameboard.pause = false\n}\nfunction pause(gameboard) {\n  return gameboard.pause = true\n}\n\nfunction createButton(text, className, onclick) {\n  const button = document.createElement('button')\n  button.className = className\n  button.onclick = onclick\n  button.innerHTML = text\n\n  return button\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/gameboard/interface.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}